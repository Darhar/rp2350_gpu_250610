/*

    static void checkAck_A1_once(const char* tag) {
        uint8_t st=0;
        if (read_ack(st)) {
            printf("%s: ACK: 0x%02X  alive=%u vsFrozen=%u mgr=%u kbd=%u ovf=%u anyDirty=%u\n",
                tag, st, (st>>0)&1, (st>>1)&1, (st>>2)&1, (st>>3)&1, (st>>4)&1, (st>>5)&1);
        } else {
            printf("%s: ACK read failed\n", tag);
        }
    }
    static bool dirty_summary(uint8_t (&out)[8]) {
        uint8_t hdr[4];
        encodeCommand(static_cast<uint8_t>(i2cCmnds::i2c_dirty_summary), 0, 0, 0, hdr);
        if (i2c_write_blocking(i2c1, I2C_SLAVE_ADDRESS, hdr, sizeof(hdr), false) != 4) return false;
        return i2c_read_blocking(i2c1, I2C_SLAVE_ADDRESS, out, 8, false) == 8;
    }

    static void checkDirtySummary() {
        uint8_t s[8]{};
        if (!dirty_summary(s)) { printf("dirty_summary: read failed\n"); return; }
        const uint8_t flags = s[0];
        const uint8_t bw    = s[1];
        const uint8_t nb    = s[2];
        const uint8_t fdb   = s[3];
        const uint32_t seq  = (uint32_t)s[4] | ((uint32_t)s[5] << 8) | ((uint32_t)s[6] << 16) | ((uint32_t)s[7] << 24);

        printf("DIRSUM: flags=0x%02X anyDirty=%u bw=%u nb=%u firstDirtyBank=%u seq=%lu\n",
            flags, (flags>>5)&1, bw, nb, (unsigned)fdb, (unsigned long)seq);
    }

    
    static bool dirty_bank_req(uint8_t bank, uint8_t options, uint32_t& outMask) {
        uint8_t hdr[4];
        encodeCommand(static_cast<uint8_t>(i2cCmnds::i2c_dirty_bank), 0, 0, 0, hdr);

        uint8_t frame[6] = { hdr[0], hdr[1], hdr[2], hdr[3], bank, options };
        int w = i2c_write_blocking(i2c1, I2C_SLAVE_ADDRESS, frame, sizeof(frame), false);
        if (w != (int)sizeof(frame)) return false;

        uint8_t resp[4]{};
        int r = i2c_read_blocking(i2c1, I2C_SLAVE_ADDRESS, resp, sizeof(resp), false);
        if (r != 4) return false;

        outMask = (uint32_t)resp[0] | ((uint32_t)resp[1] << 8) |
                ((uint32_t)resp[2] << 16) | ((uint32_t)resp[3] << 24);
        return true;
    }

    static void test_dirty_bank_once() {
        // 1) Summary (see which bank to hit)
        uint8_t sum[8]{};
        if (!dirty_summary(sum)) { printf("DIRSUM read failed\n"); return; }
        const uint8_t fdb = sum[3];
        const uint8_t anyDirty = (sum[0] >> 5) & 1;
        printf("DIRSUM: anyDirty=%u firstDirtyBank=%u seq=%lu\n",
            anyDirty, (unsigned)fdb,
            (unsigned long)((uint32_t)sum[4] | ((uint32_t)sum[5] << 8) | ((uint32_t)sum[6] << 16) | ((uint32_t)sum[7] << 24)));

        if (fdb == 0xFF) return;

        // 2) Fetch & CLEAR that bank
        uint32_t mask = 0;
        if (dirty_bank_req(fdb, 1, mask)) {
            printf("DIRBANK: bank=%u mask=0x%08lx (cleared)\n", (unsigned)fdb, (unsigned long)mask);
        } else {
            printf("DIRBANK: request failed\n");
        }

        // 3) ACK should go low if no new writes arrived
        uint8_t st=0;
        if (read_ack(st)) {
            printf("ACK: 0x%02X anyDirty=%u\n", st, (st>>5)&1);
        }
    }

    static bool changes_since_req(uint32_t lastSeq, uint8_t maxN,
                                uint32_t& curSeq, uint8_t& flags,
                                std::vector<uint16_t>& outSlots)
    {
        uint8_t hdr[4];
        encodeCommand(static_cast<uint8_t>(i2cCmnds::i2c_changes_since), 0, 0, 0, hdr);

        uint8_t frame[4 + 5] = {
            hdr[0], hdr[1], hdr[2], hdr[3],
            (uint8_t)(lastSeq >> 0), (uint8_t)(lastSeq >> 8),
            (uint8_t)(lastSeq >> 16), (uint8_t)(lastSeq >> 24),
            maxN
        };

        if (i2c_write_blocking(i2c1, I2C_SLAVE_ADDRESS, frame, sizeof(frame), false) != (int)sizeof(frame))
            return false;

        // Read header first (curSeq, flags, count)
        uint8_t head[6]{};
        if (i2c_read_blocking(i2c1, I2C_SLAVE_ADDRESS, head, sizeof(head), false) != (int)sizeof(head))
            return false;

        curSeq = (uint32_t)head[0] | ((uint32_t)head[1] << 8) |
                ((uint32_t)head[2] << 16) | ((uint32_t)head[3] << 24);
        flags  = head[4];
        const uint8_t count = head[5];

        outSlots.clear();
        if (count == 0) return true;

        // Now read the slots (2*count bytes)
        std::vector<uint8_t> buf(2 * count);
        if (i2c_read_blocking(i2c1, I2C_SLAVE_ADDRESS, buf.data(), (int)buf.size(), false) != (int)buf.size())
            return false;

        outSlots.reserve(count);
        for (uint8_t i = 0; i < count; ++i) {
            uint16_t s = (uint16_t)buf[i*2 + 0] | ((uint16_t)buf[i*2 + 1] << 8);
            outSlots.push_back(s);
        }
        return true;
    }

    static void checkRing() {
        static uint32_t lastSeq = 0;

        uint32_t curSeq = 0;
        uint8_t  flags  = 0;
        std::vector<uint16_t> slots;
        if (!changes_since_req(lastSeq, 8, curSeq, flags, slots)) {
            printf("CHGSINCE: read failed\n"); return;
        }

        const bool overflow = (flags & 0x01) != 0;
        printf("CHGSINCE: last=%lu -> cur=%lu overflow=%u count=%u\n",
            (unsigned long)lastSeq, (unsigned long)curSeq, overflow ? 1 : 0, (unsigned)slots.size());
        for (auto s : slots) {
            printf("  slot=%u\n", (unsigned)s);
        }
        lastSeq = curSeq;
    }
*/  

/*
    static void test_vs_status_once(bool clearBit) {
        uint8_t type=0, dirty=0;
        uint32_t val=0, ver=0;

        // Query System,0,2 (your MODE) — adjust if you like
        const uint8_t cat = static_cast<uint8_t>(ValueCat::Widget);
        const uint16_t a = 0, b = 2;
        uint8_t opts = clearBit ? 0x01 : 0x00;

        if (vs_status_req(cat, a, b, opts, type, val, ver, dirty)) {
            printf("VS_STATUS: (cat=%u,%u,%u) type=%u val=%lu ver=%lu dirty=%u%s\n",
                (unsigned)cat, (unsigned)a, (unsigned)b,
                (unsigned)type, (unsigned long)val, (unsigned long)ver,
                (unsigned)dirty, clearBit ? " (CLEARED)" : "");
        } else {
            printf("VS_STATUS: request failed\n");
        }
    }

    static bool dirty_clear_all(uint8_t& status) {
        uint8_t hdr[4];
        encodeCommand(static_cast<uint8_t>(i2cCmnds::i2c_dirty_clear_all), 0, 0, 0, hdr);
        if (i2c_write_blocking(i2c1, I2C_SLAVE_ADDRESS, hdr, sizeof(hdr), false) != 4) return false;
        return i2c_read_blocking(i2c1, I2C_SLAVE_ADDRESS, &status, 1, false) == 1;
    }
    // Query a widget-bound key: (Widget, activeScreenId, widgetId)
    static void test_vs_status_widget(uint32_t widgetId, bool clearBit) {
        if (!s_mgr) return;
        auto* scr = s_mgr->getActiveScreen();
        if (!scr) return;

        const uint8_t  cat = (uint8_t)ValueCat::Widget;
        const uint16_t a   = (uint16_t)scr->screenId;   // screenId at runtime
        const uint16_t b   = (uint16_t)widgetId;

        uint8_t type=0, dirty=0;
        uint32_t val=0, ver=0;

        if (vs_status_req(cat, a, b, clearBit ? 0x01 : 0x00, type, val, ver, dirty)) {
            printf("VS_STATUS[Widget:%u,%u]: type=%u val=%lu ver=%lu dirty=%u%s\n",
                (unsigned)a, (unsigned)b, (unsigned)type, (unsigned long)val,
                (unsigned long)ver, (unsigned)dirty, clearBit ? " (CLEARED)" : "");
        } else {
            printf("VS_STATUS[Widget:%u,%u]: request failed\n", (unsigned)a, (unsigned)b);
        }
    }

    // Optional: clear bank after checking, to see ACK drop to 0
    static void maybe_clear_dirty_bank_once() {
        uint8_t sum[8]{};
        if (!dirty_summary(sum)) return;
        const bool anyDirty = ((sum[0] >> 5) & 1) != 0;
        const uint8_t first = sum[3];
        if (anyDirty && first != 0xFF) {
            uint32_t mask=0;
            if (dirty_bank_req(first, 1, mask)) {
                printf("BANK CLEAR: bank=%u mask=0x%08lx\n", (unsigned)first, (unsigned long)mask);
            }
        }
    }

        // Edit value test
    static void w2_set_edit_and_check(uint16_t widgetId, int newVal, bool pause_after_ms = true) {
        if (!s_mgr) return;
        auto* scr = s_mgr->getActiveScreen();
        if (!scr) return;

        const uint8_t  cat = (uint8_t)ValueCat::Widget;
        const uint16_t a   = (uint16_t)scr->screenId;
        const uint16_t b   = widgetId;

        // 1) PUSH
        (void)vs_set_w(cat, a, b, 2, (uint32_t)newVal);   // ← removed nullptr
        printf("[W2] SET Edit (screen=%u wid=%u) -> %d\n", (unsigned)a, (unsigned)b, newVal);

        // 2) BEFORE
        uint8_t type=0, dirty=0; uint32_t val=0, ver=0;
        (void)vs_status_req(cat, a, b, 0, type, val, ver, dirty);
        printf("[W2] BEFORE  status: type=%u val=%lu ver=%lu dirty=%u\n",
            (unsigned)type, (unsigned long)val, (unsigned long)ver, (unsigned)dirty);

        if (pause_after_ms) sleep_ms(200); // ≥ VS_WIDGET_POLL_MS

        // 3) AFTER
        (void)vs_status_req(cat, a, b, 0, type, val, ver, dirty);
        printf("[W2] AFTER   status: type=%u val=%lu ver=%lu dirty=%u\n",
            (unsigned)type, (unsigned long)val, (unsigned long)ver, (unsigned)dirty);

        uint8_t ack=0; read_ack(ack);
        printf("[W2] ACK=0x%02X anyDirty=%u\n", ack, (ack>>5)&1);
    }

    // Button value test
    static void w2_set_button_and_check(uint16_t widgetId, bool newState, bool pause_after_ms = true) {
        if (!s_mgr) return;
        auto* scr = s_mgr->getActiveScreen();
        if (!scr) return;

        const uint8_t  cat = (uint8_t)ValueCat::Widget;
        const uint16_t a   = (uint16_t)scr->screenId;
        const uint16_t b   = widgetId;

        (void)vs_set_w(cat, a, b, 1, newState ? 1u : 0u);  // ← removed nullptr
        printf("[W2] SET Button (screen=%u wid=%u) -> %u\n",
            (unsigned)a, (unsigned)b, (unsigned)newState);

        uint8_t type=0, dirty=0; uint32_t val=0, ver=0;
        (void)vs_status_req(cat, a, b, 0, type, val, ver, dirty);
        printf("[W2] BEFORE  status: type=%u val=%lu ver=%lu dirty=%u\n",
            (unsigned)type, (unsigned long)val, (unsigned long)ver, (unsigned)dirty);

        if (pause_after_ms) sleep_ms(200);

        (void)vs_status_req(cat, a, b, 0, type, val, ver, dirty);
        printf("[W2] AFTER   status: type=%u val=%lu ver=%lu dirty=%u\n",
            (unsigned)type, (unsigned long)val, (unsigned long)ver, (unsigned)dirty);

        uint8_t ack=0; read_ack(ack);
        printf("[W2] ACK=0x%02X anyDirty=%u\n", ack, (ack>>5)&1);
    }
static inline uint32_t u32_from_le(const uint8_t* p) {
    return (uint32_t)p[0] | ((uint32_t)p[1] << 8) | ((uint32_t)p[2] << 16) | ((uint32_t)p[3] << 24);
}


// Simple observer for a (Widget, screenId, widgetId) tuple
static void obs_widget(uint16_t sid, uint16_t wid) {
    const uint8_t cat = (uint8_t)ValueCat::Widget;
    uint8_t type = 0, dirty = 0;
    uint32_t val = 0, ver = 0;
    if (vs_status_req(cat, sid, wid, 0, type, val, ver, dirty)) {
        printf("[OBS] (Widget:%u,%u) type=%u val=%lu ver=%lu dirty=%u\n",
               (unsigned)sid, (unsigned)wid,
               (unsigned)type, (unsigned long)val, (unsigned long)ver, (unsigned)dirty);
    } else {
        printf("[OBS] (Widget:%u,%u) status read failed\n", (unsigned)sid, (unsigned)wid);
    }
}

// Optional: print compact dirty summary + ACK
static void obs_summary_and_ack() {
    uint8_t sum[8] = {0};
    if (dirty_summary(sum)) {
        const uint8_t flags = sum[0];
        const uint8_t firstDirtyBank = sum[3];
        const uint32_t seq = u32_from_le(&sum[4]);
        printf("DIRSUM: anyDirty=%u firstDirtyBank=%u seq=%lu\n",
               (flags >> 5) & 1, (unsigned)firstDirtyBank, (unsigned long)seq);
    }
    uint8_t ack = 0;
    if (read_ack(ack)) {
        printf("ACK: 0x%02X anyDirty=%u\n", ack, (ack >> 5) & 1);
    }
}

static void obs_widget(uint16_t sid, uint16_t wid, bool clearDirty) {
    const uint8_t cat = (uint8_t)ValueCat::Widget;
    uint8_t  type = 0, dirty = 0;
    uint32_t val  = 0, ver = 0;

    if (vs_status_req(cat, sid, wid, clearDirty ? 1 : 0, type, val, ver, dirty)) {
        printf("[OBS] (Widget:%u,%u) type=%u val=%lu ver=%lu dirty=%u%s\n",
               (unsigned)sid, (unsigned)wid, (unsigned)type,
               (unsigned long)val, (unsigned long)ver, (unsigned)dirty,
               clearDirty ? " (CLEARED)" : "");
    } else {
        printf("[OBS] (Widget:%u,%u) status read FAILED\n", (unsigned)sid, (unsigned)wid);
    }
}

static void obs_summary() {
    uint8_t sum[8] = {};
    if (dirty_summary(sum)) {
        const uint8_t flags = sum[0];
        const uint8_t fdb   = sum[3];
        const uint32_t seq  = u32_from_le(&sum[4]);
        printf("DIRSUM: anyDirty=%u firstDirtyBank=%u seq=%lu\n",
               (flags >> 5) & 1, (unsigned)fdb, (unsigned long)seq);
    }
}

*/

/*
static uint32_t last_ui_commit = 0;
static uint32_t ui_quiet_until = 0;

static void update_ui_quiet_window() {
    uint8_t  type=0, dirty=0;
    uint32_t val=0, ver=0;
    // Read (System,0,50)
    if (vs_status_req((uint8_t)ValueCat::System, 0, 50, 0, type, val, ver, dirty)) {
        if (val != last_ui_commit) {
            last_ui_commit = val;
            ui_quiet_until = now_ms() + 600;   // match your UI cooldown window
            printf("[W2] quiet window until +600ms (uiCommit=%lu)\n", (unsigned long)val);
        }
    }
}
// Simple per-slot INT driver
struct IntDriver {
    uint16_t sid;           // screenId
    uint16_t wid;           // widgetId
    uint8_t  type;          // WT_Int = 2
    int32_t  target;        // what we want to drive towards
    uint32_t last_ver;      // last seen version
    uint32_t quiet_until;   // ms timestamp to pause driving after adopting
    bool     initialized;
};

// Read status (no clear), adopt if user changed it, and drive if needed.
static void tick_int_driver(IntDriver& d, bool allow_drive) {
    // Resolve screen id from the active screen if available (fallback to existing)
    if (s_mgr) {
        if (auto* scr = s_mgr->getActiveScreen()) {
            d.sid = (uint16_t)scr->screenId;
        }
    }

    uint8_t  type=0, dirty=0;
    uint32_t val=0, ver=0;

    // 1) Read current store state for this widget (no clear so we don't eat UI dirty)
    if (!vs_status_req((uint8_t)ValueCat::Widget, d.sid, d.wid, 0, type, val, ver, dirty)) {
        printf("[DRV] status read FAILED (sid=%u wid=%u)\n", (unsigned)d.sid, (unsigned)d.wid);
        return;
    }

    if (!d.initialized) {
        // First snapshot: adopt the store as baseline
        d.type       = type;
        d.target     = (int32_t)val;
        d.last_ver   = ver;
        d.quiet_until= now_ms(); // no quiet delay on first touch
        d.initialized= true;
        printf("[DRV] init sid=%u wid=%u adopt=%ld ver=%lu\n",
               (unsigned)d.sid, (unsigned)d.wid, (long)d.target, (unsigned long)d.last_ver);
        return;
    }

    // 2) Detect external/user change: version advanced and value differs from our current target
    if (ver != d.last_ver && (int32_t)val != d.target) {
        d.target      = (int32_t)val;       // ADOPT the user value as new baseline
        d.last_ver    = ver;
        d.quiet_until = now_ms() + 600;     // short quiet window so we don't fight the UI
        printf("[DRV] adopt sid=%u wid=%u newTarget=%ld ver=%lu\n",
               (unsigned)d.sid, (unsigned)d.wid, (long)d.target, (unsigned long)ver);
        return; // don’t drive in the same tick
    }

    // 3) If we're inside the quiet window, just watch
    const uint32_t tnow = now_ms();
    if (tnow < d.quiet_until) return;

    // 4) Demo drive: nudge the target upward and write it back (only if allowed)
    //    For your real logic, compute d.target however you like (PID/ramp/etc.)
    if (allow_drive) {
        // Example demo: if store already equals target, advance target for the next step
        if ((int32_t)val == d.target) {
            // advance demo target but START FROM current store value, so adoption is respected
            int32_t next = d.target + 1;
            if (next > 60) next = 40; // wrap like your earlier demo
            d.target = next;
        }

        // If store differs from our target, write the target
        if ((int32_t)val != d.target) {
            if (vs_set_w((uint8_t)ValueCat::Widget, d.sid, d.wid, 2, (uint32_t)d.target)) {
                // After our write, the store will bump version; capture on next tick.
                printf("[DRV] set sid=%u wid=%u -> %ld (prev val=%lu ver=%lu)\n",
                       (unsigned)d.sid, (unsigned)d.wid, (long)d.target,
                       (unsigned long)val, (unsigned long)ver);
            } else {
                printf("[DRV] set FAILED sid=%u wid=%u\n", (unsigned)d.sid, (unsigned)d.wid);
            }
        }
    }
}

void run_master() {
    // Optionally edge-print ACK so you can see when anything becomes dirty
    static bool     first   = true;
    static uint8_t  lastAck = 0xFF;
    uint8_t ack = 0;
    if (read_ack(ack)) {
        if (first || ack != lastAck) {
            printf("ACK: 0x%02X anyDirty=%u\n", ack, (unsigned)((ack >> 5) & 1));
            lastAck = ack;
            first   = false;
        }
    }

    // Drive the TestScreen Edit widget (wid=2). You can add more drivers if needed.
    static IntDriver drv_edit{ 1, 2, 2,0, 0, 0, false };
    tick_int_driver(drv_edit, true);

    sleep_ms(200); // keep this small so adoption feels instant
}

    void run_master_orig() {
        if (!s_mgr) return;

        uint8_t buffer[4];
        //encodeCommand(cmdId,flags,screenId,paramBits, uint8_t (&bytes)[4])
        encodeCommand(static_cast<uint8_t>(i2cCmnds::i2c_scrCng), 0, 2, 0x12345, buffer);
        DEBUG_PRINTLN("run_master sending %d bytes\n",sizeof(buffer));
        i2c_write_blocking(i2c1, I2C_SLAVE_ADDRESS, buffer, 4, false);
        sleep_ms(1000);
        encodeCommand(static_cast<uint8_t>(i2cCmnds::i2c_scrCng), 0, 1, 0x12345, buffer);
        i2c_write_blocking(i2c1, I2C_SLAVE_ADDRESS, buffer, 4, false);
        sleep_ms(10000);
    }

*/

