
=========== Add a amenu ==============

#include <cstdint>

class Menu {
private:
    const char* items[4];    // Fixed size for simplicity and memory efficiency
    int selected = 0;
    int numItems;

public:
    // Constructor with fixed items
    Menu(const char* item1, const char* item2, const char* item3, const char* item4) {
        items[0] = item1;
        items[1] = item2;
        items[2] = item3;
        items[3] = item4;
        numItems = 4;  // Hardcoded to 4 items
    }

    void draw() const {
        printf("[Menu]\n");
        for (int i = 0; i < numItems; ++i) {
            if (i == selected) {
                printf(" > %s\n", items[i]);
            } else {
                printf("   %s\n", items[i]);
            }
        }
    }

    void moveUp() {
        if (selected > 0) {
            selected--;
        }
    }

    void moveDown() {
        if (selected < numItems - 1) {
            selected++;
        }
    }

    int getSelectedIndex() const {
        return selected;
    }

    const char* getSelectedItem() const {
        return items[selected];
    }

    int getSize() const {
        return numItems;
    }
};

-------------- use it in a screen ----------------

class MenuScreen : public Screen {
private:
    Menu menu;  // Menu object for this screen

public:
    MenuScreen(ScreenCallback cb, void* ctx)
        : Screen(cb, ctx), menu("Settings", "Status", "About", "Exit") {}

    void draw() override {
        printf("[MenuScreen] Drawing menu...\n");
        menu.draw();
    }

    void keyPressed(uint8_t key) override {
        switch (key) {
            case 1:  // Up
                menu.moveUp();
                break;
            case 2:  // Down
                menu.moveDown();
                break;
            case 3:  // Select
                if (callback) {
                    callback(context, 2, menu.getSelectedIndex());
                }
                return;
        }
        draw();  // Redraw the menu after a key press
    }
};

------------ Screen Manager Integration -----------

void screenCallback(void* ctx, int8_t screenId, uint8_t key) {
    AppContext* appCtx = static_cast<AppContext*>(ctx);

    if (screenId == 0 && key == 1) {
        appCtx->screenMgr->setScreen(new MenuScreen(screenCallback, ctx));
    } else if (screenId == 2) {
        // Handle the menu selection (key represents the selected menu item index)
        printf("[App] Menu option %d selected: %s\n", key, appCtx->screenMgr->getSelectedItem());

        // You can switch to different screens based on the selected item here
    }
}

----------- main ---------------
int main() {
    ScreenManager manager;
    AppContext appCtx = {
        .appName = "MyApp",
        .screenMgr = &manager
    };

    // Start with a menu screen
    manager.setScreen(new MenuScreen(screenCallback, &appCtx));

    // Simulate some key events
    manager.sendKey(2);  // Down
    manager.sendKey(1);  // Up
    manager.sendKey(3);  // Select (get selected option)

    return 0;
}

============================
Asked chat gpt to write code for a label inherited from a widget class, then two drawn from an array, 
then button and label drawn from an array
I got each step working before moving on to the next step, when the two different widgets were working
I moved the definitions to a separate header file.
============ 250513 =================
Widgets working label, button, edit. Looking to do lcd update only as needed, so saved it here.

============250517=========================

Added redraw variable to screen class to hold the area of frame buffer to redraw  , updating screens and keyboard 
handlers changes the redraw area, at the moment this is the whole screen.

===========================================
lcd
    DIS_RE 3    //9-22
    DIS_DC 4    //6-25
    DIS_CS 5    //7-24
    DIS_CLK 6   //4-27
    DIS_SI 7    //5-26

i2c

slave (display)
    QW/ST connector
    12c0
    scl 13
    sda 12
    looking with usb on top
    |gnd|3v3|sda|scl|

master (core1)
    12c1
    scl 27
    sda 26

rtc
 
 male rtc connector on nec board
 ____________________
 |- | nc | C | D | + |
 ---------------------

    C: I2C_SCL		27	
    D: I2C_SDA		26 

key pad

    pin 29
----------- i2c -------------
 
int 	i2c_write_blocking_until (i2c_inst_t *i2c, uint8_t addr, const uint8_t *src, size_t len, bool nostop, absolute_time_t until)
 	Attempt to write specified number of bytes to address, blocking until the specified absolute time is reached. 
 
int 	i2c_read_blocking_until (i2c_inst_t *i2c, uint8_t addr, uint8_t *dst, size_t len, bool nostop, absolute_time_t until)
 	Attempt to read specified number of bytes from address, blocking until the specified absolute time is reached. 
 
static int 	i2c_write_timeout_us (i2c_inst_t *i2c, uint8_t addr, const uint8_t *src, size_t len, bool nostop, uint timeout_us)
 	Attempt to write specified number of bytes to address, with timeout. 
 
static int 	i2c_read_timeout_us (i2c_inst_t *i2c, uint8_t addr, uint8_t *dst, size_t len, bool nostop, uint timeout_us)
 	Attempt to read specified number of bytes from address, with timeout. 
 

int 	i2c_write_blocking (i2c_inst_t *i2c, uint8_t addr, const uint8_t *src, size_t len, bool nostop)
 	Attempt to write specified number of bytes to address, blocking. 
 
int 	i2c_read_blocking (i2c_inst_t *i2c, uint8_t addr, uint8_t *dst, size_t len, bool nostop)
 	Attempt to read specified number of bytes from address, blocking. 
 
static void 	i2c_write_raw_blocking (i2c_inst_t *i2c, const uint8_t *src, size_t len)
 	Write direct to TX FIFO. 
 
static void 	i2c_read_raw_blocking (i2c_inst_t *i2c, uint8_t *dst, size_t len)
 	Read direct from RX FIFO. 
 


static size_t 	i2c_get_write_available (i2c_inst_t *i2c)
 	Determine non-blocking write space available. 
 
static size_t 	i2c_get_read_available (i2c_inst_t *i2c)
 	Determine number of bytes received. 
 

static uint8_t 	i2c_read_byte_raw (i2c_inst_t *i2c)
 	Pop a byte from I2C Rx FIFO.This function is non-blocking and assumes the Rx FIFO isn't empty. 
 
static void 	i2c_write_byte_raw (i2c_inst_t *i2c, uint8_t value)
 	Push a byte into I2C Tx FIFO.This function is non-blocking and assumes the Tx FIFO isn't full. 
 

static uint 	i2c_get_dreq (i2c_inst_t *i2c, bool is_tx)
 	Return the DREQ to use for pacing transfers to/from a particular I2C instance. 

------ i2c interactions ----------------
The master can write and read to the slave
a pointer to a buffer is provided to contain the data to be written or read data into it



----- i2c multiple byte send receive  -------
The master slave example for pico sent and displayed single bytes
I wanted to receive a buffer full of bytes.  Used chatgpt and after a few refinments
I got what I wanted 250526

----- i2c -------------
Writing 
We can write a single or multiple bytes to the slave
When writing multiple bytes, the first is the command

Here are some ideas for i2c communications
single byte write (no return values expected),multi byte write (no return values expected),single and multi byte Read functions (return values expected)
the format ive used here is 
command Description command name,   parameters  returned values(if requested)    
----- Write functions
Single byte write functions
    turn screen on  scrOn 
    turn screen off scrOf

Multiple bytes write functions
    Change screen   scrCng ,    screen id
    Change label text     txtCng ,    screen id,label widget index, string size,text
    Load image      imgLod ,     screen id,image widget Index, data Size,data
    move image      imgMov ,     screen id,position x, position y

Read functions (requests)
    Get button status   butGet, button widget index  returns state
    get Text            txtGet, screen id, widget id, returns text size,text
    has ui status changed       uiGet, returns bool
    get ui changes      uiCng,  returns size,ids
 ------------
 master uc              
 cmnd           cmnd -> create i2cRec object -> update system
 cmnd + data    cmnd + data -> 
 cmnd req 
 -------------------------------


------ 250612 -----
rearranged file system working

------ 250616 -----
started screen discriptor


using ScreenFactoryFunc = Screen* (*)(void (*)(int8_t, uint8_t), uint8_t);

Breakdown
    using ScreenFactoryFunc = ...;:
    This creates a new type alias named ScreenFactoryFunc.

    Screen*:
        This is the return type of the function being aliased â€” a pointer to a Screen object.

    (*)(...):
        This means that ScreenFactoryFunc is a pointer to a function.

    void (*)(int8_t, uint8_t):
        This is the first parameter of the function â€” a pointer to another function that returns void and takes two parameters: an int8_t and a uint8_t.

    uint8_t:
        This is the second parameter of the function.

    Full Meaning
        ScreenFactoryFunc is now a shorthand for a function pointer type that:

    Takes two arguments:

        A function pointer: void (*)(int8_t, uint8_t)
        A uint8_t value

    Returns: a Screen*

Example Function Signature
Here is an example function that matches this signature:

    Screen* createBasicScreen(void (*callback)(int8_t, uint8_t), uint8_t option) {
        return new BasicScreen(callback, option);
    }

You could assign this function to a variable of type ScreenFactoryFunc:

    ScreenFactoryFunc factory = &createBasicScreen;

TL;DR
using ScreenFactoryFunc = Screen* (*)(void (*)(int8_t, uint8_t), uint8_t);
This defines a type for functions that create a Screen, requiring:

A callback function of type void(int8_t, uint8_t), and

A uint8_t option as parameters.

static ScreenFactoryFunc factories[SCREEN_COUNT] = {
    [](void (*cb)(int8_t, uint8_t), uint8_t opt) -> Screen* {
        return new BasicScreen(cb, opt);
    }
};

So, each element of factories[] is a pointer to a function that:

    Returns a Screen*

    Accepts two arguments:

        A callback of type void(int8_t, uint8_t)
        A uint8_t option

static makes the factories array persist across function calls and limits its visibility to the current translation unit (usually the .cpp file). 
This is good for internal lookup tables.

2. Initializing the array with a lambda function

    [](void (*cb)(int8_t, uint8_t), uint8_t opt) -> Screen* {
        return new BasicScreen(cb, opt);
    }

This is a lambda expression, a way of defining an anonymous function inline.

    []: Capture clause â€” in this case, empty, meaning the lambda does not capture any local variables.

    (void (*cb)(int8_t, uint8_t), uint8_t opt): The parameters the lambda accepts. The first is a callback function pointer, the second is a simple byte option.

    -> Screen*: The lambda returns a pointer to a Screen.

    return new BasicScreen(cb, opt);: It dynamically allocates a new BasicScreen with the given parameters and returns it.

Because the lambda has no captures, the compiler can convert it to a function pointer, which is why it is compatible with ScreenFactoryFunc.

3. Putting it all together
You now have a statically defined array of screen factory functions, where factories[0] (or whichever index) points to a function that creates a BasicScreen.

You can later call:

    Screen* s = factories[0](myCallbackFunc, 42);

TL;DR

    static ScreenFactoryFunc factories[SCREEN_COUNT] = {
        [](void (*cb)(int8_t, uint8_t), uint8_t opt) -> Screen* {
            return new BasicScreen(cb, opt);
        }
    };
This creates a static array of screen-creating functions, using lambda functions with no captures, so they can be stored as function pointers. 
Each entry returns a different type of screen â€” in this case, a BasicScreen.

------ Lambda ----------
Lambda expressions in C++ are a concise way to define anonymous functionsâ€”functions that donâ€™t have a name. 
They're especially useful for short bits of functionality that are passed as arguments (e.g., to std::sort, std::for_each, or in your case, screen factories).

-- Basic Syntax

    [ capture ] ( parameters ) -> return_type {
        // function body
    };

Example

    auto add = [](int a, int b) -> int {
        return a + b;
    };
    int result = add(2, 3);  // result = 5

-- Breakdown of Components
Part	        Description
[]	            Capture list: used to capture variables from the surrounding scope
(int a, int b)	Parameter list
-> int	        Return type (optional if the compiler can infer it)
{ ... }	        Function body

-- Lambda Without Capture
A lambda with no capture can decay to a function pointer, which is how you're using it in:

    []() -> Screen* { return new BasicScreen(); }
This is legal as long as:

    You don't reference anything outside the lambda.
    You don't use [this], [&], or [=] to capture.

Such lambdas can be stored in arrays of function pointers:

    using FactoryFunc = Screen* (*)();
    FactoryFunc arr[] = {
        []() -> Screen* { return new MyScreen(); }
    };

-- Lambdas With Capture
If you use variables from the surrounding scope, you must capture them:

    int x = 5;
    auto addX = [x](int y) { return x + y; };  // capture x by value
Or by reference:

    auto addX = [&x](int y) { return x + y; };  // capture x by reference
Captured lambdas can't be converted to function pointers unless theyâ€™re stateless.

-- Lambda as Replacement for Named Function
Instead of writing:

    Screen* createMenuScreen() {
        return new MenuScreen();
    }
    mgr.registerFactory(MENUSCREEN, createMenuScreen);

You can just do:

    mgr.registerFactory(MENUSCREEN, []() -> Screen* { return new MenuScreen(); });

TL;DR
    Lambdas are inline anonymous functions.
    Use [] to capture variables if needed.
    Lambdas without captures can act as function pointers.
    They're ideal for short, local functionality (like factory registration).

----- key return ----
a screen returns an int value to the screenManager anfer a key pressed
This value is returned to the keyDown,keyPressed or keyReleased function
I could either 
    store a value for each of these function,
    each functin deal with the returned value
    encode the function in the value
I want the value to store,
    screen id
    a command
I have 32 bits to play with
I would like 256 screen ids (8 bits) 24 left
16 commands                 (4 bits) 20 left

----------- 7. Dynamic Screen Persistence
To support on-demand screen creation without losing state, we introduced a descriptor-based design

//---  WidgetDescriptor & ScreenDescriptor
    struct WidgetDescriptor {
        WidgetType type;
        uint32_t widgetId;
        std::string initialText;
        int x, y, width, height;
        // additional persistent stateâ€¦
    };

    struct ScreenDescriptor {
        ScreenEnum id;
        std::vector<WidgetDescriptor> widgets;
        // e.g., selected option, scroll offsets, etc.
    };


//---  Persistent Updates
When a command changes a widget:

    auto& desc = screenData[targetScreen];
    auto& wd   = findWidgetDescriptor(desc, widgetId);
    wd.initialText = newText; // persist
    if (activeScreen == targetScreen) {
        updateLiveWidget(widgetId, newText);
    }


//--- 

using ScreenFactoryFunc = std::function<Screen*()>;  
// Or a raw functionâ€pointer: Screen* (*)(void)

class ScreenManager {
public:
    // Register at startup:
    void registerScreen(ScreenEnum id, ScreenFactoryFunc factory) {
      factories[id] = std::move(factory);
      // Also init a blank descriptor if you like:
      if (!screenData.count(id)) {
        screenData[id] = ScreenDescriptor{ id, {} };
      }
    }

    Screen* buildScreenFromDescriptor(ScreenEnum id);

private:

    std::map<ScreenEnum, ScreenDescriptor>    screenData;
    std::map<ScreenEnum, ScreenFactoryFunc>   factories;
};

//----- In your ScreenManager.cpp -----

Screen* ScreenManager::buildScreenFromDescriptor(ScreenEnum id) {
    // 1) Find the factory
    auto fit = factories.find(id);
    if (fit == factories.end()) {
        return nullptr;    // or throw, or fallback
    }

    // 2) Use it to create the right subclass
    Screen* screen = fit->second();  

    // 3) Rebuild widgets from the descriptor
    const auto& desc = screenData.at(id);
    for (auto& wd : desc.widgets) {
        Widget* w = createWidgetFromDescriptor(wd);
        screen->addWidget(w, wd.widgetId);
    }

    // 4) (Optionally) restore any screen-level state:
    //    e.g. screen->setSelected(desc.selectedIndex);

    return screen;

}

//----  And then in your initialization code (perhaps in a registerAllScreens() function):
screenManager.registerScreen(ScreenEnum::About,
    []() -> Screen* { return new AboutScreen(/*ctor args*/); }
);
screenManager.registerScreen(ScreenEnum::Settings,
    []() -> Screen* { return new SettingsScreen(/*ctor args*/); }
);
// â€¦and so on for each concrete screenâ€¦



describing screens
// somewhere in your initialization code, e.g. in main.cpp or a registerScreens() helper

// 1) First, register the factory for TestScreen
screenManager.registerScreen(ScreenEnum::TESTSCREEN, []() -> Screen* {
    return new TestScreen();
});

// 2) Then, *initialize* its descriptor exactly once (so buildScreenFromDescriptor
//    will recreate the same widgets on every rebuild):

auto &desc = screenManager.getDescriptor(ScreenEnum::TESTSCREEN);
if (desc.widgets.empty()) {
    // widgetId must be unique perâ€screen
    desc.widgets.push_back({
        WidgetType::LABEL,    // type
        /*widgetId=*/1,
        /*initialText=*/"First Label",
        /*x=*/5, /*y=*/15, /*w=*/20, /*h=*/10
    });
    desc.widgets.push_back({
        WidgetType::BUTTON,
        /*widgetId=*/2,
        /*initialText=*/"Click",  // button label
        5, 28, 100, 10
    });
    desc.widgets.push_back({
        WidgetType::EDIT,
        /*widgetId=*/3,
        /*initialText=*/"",       // initial contents
        5, 42, 100, 10
    });
    // any other screenâ€level state:
    // desc.selectedIndex = 0;
}

// 3) Later, when you need a live Screen*:
Screen* live = screenManager.buildScreenFromDescriptor(ScreenEnum::TESTSCREEN);
// live->draw(...); live->update(...), etc.

//--- using FactoryFunc = Screen* (*)();

using FactoryFunc = Screen* (*)();
is a type alias declaration using the using keyword (introduced in C++11), which is a more readable alternative to typedef.

ğŸ” Breaking It Down
1. Screen*
This is the return type of the function â€” a pointer to a Screen object.

2. (*)()
This means the type is a pointer to a function that:

    Takes no parameters (the empty ()),
    Returns a Screen*.

3. using FactoryFunc = ...;
This defines a new alias called FactoryFunc. So now, wherever you write FactoryFunc, it means Screen* (*)().

âœ… What It Represents
FactoryFunc is a pointer to a function that returns a Screen* and takes no parameters.

ğŸ§± Example
This function:

    Screen* createBasicScreen() {
        return new BasicScreen();
    }
Matches the FactoryFunc type, so you can do:

    FactoryFunc func = createBasicScreen;
    Screen* screen = func();  // Calls createBasicScreen()
Or use a lambda (as long as it has no captures):

    FactoryFunc func = []() -> Screen* {
        return new BasicScreen();
    };

ğŸ§  Why It's Useful
You use FactoryFunc when:

    You want to register a set of screen constructors,
    You want to store them in an array or map,
    And later create screens by calling the function pointer:


    std::map<ScreenEnum, FactoryFunc> factories;
    factories[BASICSCREEN] = []() -> Screen* { return new BasicScreen(); };

    // To create:
    Screen* s = factories[BASICSCREEN]();

//------------------------
    Screen* screen = new Screen();
is trying to instantiate your abstract base class Screen. Because youâ€™ve declared pure-virtual methods in Screen:

virtual void update(...) = 0;
virtual void draw(...)   = 0;
â€¦
it has no concrete constructor you can callâ€”thereâ€™s no full implementation behind those methodsâ€”so you cannot do new Screen(). 
The compiler will reject it with an â€œcannot instantiate abstract classâ€ error.

What you actually want
Instead of calling new Screen() you need to invoke the factory that creates the appropriate derived class (e.g. TestScreen, MenuScreen, 
etc.). 
That factory will call new TestScreen() (or whichever screen type) under the hood, giving you a concrete object you can work with.

So replace:

// âŒ WRONG: Screen is abstract, canâ€™t new it
Screen* screen = new Screen();
with something like:

// âœ… RIGHT: use the registered factory for this screen ID
auto factory = factories.at(id);
Screen* screen = factory();   // e.g. calls new TestScreen()
That way you get a proper instance of a subclass that implements all the virtual methods, and your buildScreenFromDescriptor 
will compile and run as intended.

//------------------

Screen* screen = it->second();

Here, it is an iterator into the factories map (std::map<ScreenEnum, ScreenFactoryFunc>). 

    it->first is the key (the ScreenEnum),
    it->second is the value (the ScreenFactoryFunc itself, i.e. a callable object or function pointer).

The line;

    Screen* screen = it->second();

gets the factory function stored in the map at that iterator,

Invoking it with ()â€”which calls whatever lambda or function pointer you previously registered,

it->second() means â€œcall the factory associated with this ScreenEnum and return a 
freshly new-allocated instance of the concrete Screen subclass (e.g. new TestScreen())..â€

//----250621---- screen descriptors working
//----250629 --- persistent values working
------250630 --------
Label, Button and Edit widgets working correctly
//----250701 --- label, button and edit widget working correctly

----- todo soon
test spi connection is working
work out what should controllable via spi
design and create other widgets, gui elements
create other pages

---Adding serial debug interface
created Debug class
serial commands for 
    memory usage, 
    viewing memory at address
    viewing variables
    viewing frame buffer 

--- setting screen

in main.cpp add the screen
void registerAllScreens(ScreenManager& mgr) {
    // Build a non-static array so lambdas can capture mgr
    ScreenFactoryFunc screenObjects[SCREEN_COUNT] = {
        [&mgr]() -> Screen* { return new MenuScreen(mgr); },
        [&mgr]() -> Screen* { return new TestScreen(mgr); },
        [&mgr]() -> Screen* { return new SettingsScreen(mgr); },
        //[&mgr]() -> Screen* { return new AboutScreen(mgr); },
        //[&mgr]() -> Screen* { return new BasicScreen(mgr); },
    };

in screenManager.hpp change the SCREENCOUNT

change the screen constructor

in the .h change the constructor format and add constructor code from .cpp file
    SettingsScreen(ScreenManager& mgr) : mgr(mgr){
        screenId = ScreenEnum::SETTINGSSCREEN;
        title =  "Splash Screen";
        refresh=Rect2(0,0,158,64);
    }

remove the constructor from the .cpp file

add these function
	void addWidget(Widget* widget,uint32_t widgetId);
add this attribute to .h
    int selectedIndex = -1;

if the screen has widgets do these extra things;    
    void buildFromDescriptor();

modify the deconstructor

add the widgets to registerAllScreens() in main.cpp

------- declaring the menu --------------------
Option 1: Mark menuB as inline in the header (C++17 or later)

    inline std::vector<std::string> menuB {
        "Item A" ,
        "Item B" ,
        "Item i"
    };

Option 2: Declare menuB as extern in the header, define it in a .cpp
In your header (.h):

    extern std::vector<std::string> menuB;

In one .cpp file (e.g., settings_screen.cpp):

    #include "settings_screen.h"

    std::vector<std::string> menuB {
        "Item A",
        "Item B",
        "Item i"
    };

Option 3: Move the definition inside the constructor (if not reused elsewhere)

    SettingsScreen(ScreenManager& mgr) : mgr(mgr) {
        screenId = ScreenEnum::SETTINGSSCREEN;
        title =  "Splash Screen";
        std::vector<std::string> menuB {
            "Item A", "Item B", "Item i"
        };
        menu1 = new Menu(menuB, 40);
        refresh = Rect2(0,0,158,64);
    }
This avoids the global altogether. Only do this if menuB is only used inside SettingsScreen

------ screen creation sequence ------
[SM]        Keypressed
[SM]        activeScreen->Keypressed
[screen]    return encodeKeyReturn
[SM]        setActiveScreen
                buildScreenFromDescriptor
                    auto curFactory = screenObjects.find(id);
                    Screen* screen = curFactory->second();                
[screen]                constructor
[screen]                seedDescriptor
[screen]                rebuild
[SM]                        createWidgetFromDescriptor
                                case: widgetType
                                    new widget object
[widget]                                constructor
[screen]                constructor done
[SM]        return screen    

------250705--------
added debug
------250713--------
menu widget working
should look in to all widget having a value field
menu widget could use it for initalselectedMenuItem

the fields used in the descriptor are just for parameters 
which will change and need to be stored between screen changes
So reallty its just the value of the widget

------ genericerise the widgets   ---------------
I want all the widgets to use the same amount of space to store persistant data

so all widgets will have 32 bits for a value and flags
and a text buffer
A console widget will have a buffer of a definesd size
There will be a specific edit widget to handle fractions
Text input needs a special widget, on screen there is room for 5 rows and 22 clumns of letters in boxes

------ 250727 -------
Added a trace system and spreadsheet parser

------ 250808 ---------
seed config and state working

-----------fixing circular includes------------
Hereâ€™s a concise recap of what we did to swap out the old includeâ€guard for #pragma once and smooth over the resulting includeâ€order issues:

1. In screen.h

Removed the

	#ifndef SCREEN_H
	#define SCREEN_H
	â€¦ 
	#endif
Added a single line at the top:

	#pragma once
Dropped the #include "screenManager.hpp" (which had been causing a circular include).

Forwardâ€declared class ScreenManager; so seedState() and rebuildFromDescriptor() could still reference it.

2. In every derivedâ€screen header (e.g. settingsscreen.h)

Removed any standalone copy of the enum ScreenEnum { â€¦ }.

Added #include "screen.h" instead, to get both Screen and ScreenEnum exactly once.

3. In screenManager.hpp

Ensured Screen and ScreenEnum are declared before use by either:

Including screen.h at the top (with #pragma once preventing recursion), or

Forwardâ€declaring them before the using ScreenFactoryFunc and map declarations.

Pulled in <map> so std::map<ScreenEnum,â€¦> is known.

------ 250823 -----
reorganise demos

------ 250824 -----
better setup for demos

------- 250823 -----
added i2c keyboard command
------- 250831 -----
store values i2c working
-------250831_1 ----
start phased implementation of full store values
-------250831_2 ----
store values phase A2
-------250831_3 ----
store values phase A3
-------250831_4 ----
store values phase A5

use the ValueStore as the authoritative state ledger, and use commands for events/one-shots/transaction boundaries/low-latency hints. 
The two complement each other rather than compete.

Hereâ€™s how Iâ€™d split responsibilities and why.

When to use the ValueStore (VS)
Use VS for anything that is:
    Durable, observable state that both sides should agree on (and can read any time).
    Idempotent (setting the same value twice is fine).
    Bindable to the UI (widgets), firmware behaviors, or policy.

Examples:
    UI widget values (sliders, toggles, menu selections)
    Keyboard snapshot (pressedMask), LED mask, audio volume (not â€œplayâ€; see below)
    Modes / flags / system config
    â€œActive screenâ€, â€œfocused widgetâ€ (authoritative UI plane)
    Sensor readings and derived values

Key point: 
Core0 (slave) doesnâ€™t need to â€œpollâ€ VS for master-originated changes. 
Your IÂ²C vs_set handler is already on the hot pathâ€”after writing VS it can react immediately or enqueue a lightweight â€œkickâ€ for the main loop. 
Polling VS is only needed for third-party producers (UI, timers, sensors) that change values outside the IÂ²C handler; 
and even then we made it efficient with A1â€“A6 (any-dirty, dirty banks, changes-since ring, per-slot status).

When to use Commands 
Use commands when the operation is:
    A one-shot side effect (not a steady value), or
    Needs a transaction boundary / â€œcommitâ€ semantics, or
    Requires tight latency notification semantics, or
    Transfers bulk/streamed data that doesnâ€™t belong as a single 32-bit slot.

Examples:
    â€œPlay beepâ€, â€œstart haptic pulseâ€, â€œflash LED pattern for 200 msâ€
    â€œSave settings to flashâ€, â€œfactory resetâ€, â€œrebootâ€
    â€œLoad asset block #Nâ€, â€œupload font chunkâ€
    â€œApply nowâ€ / â€œCommit groupâ€ (after writing a bunch of VS keys)
    Protocol/telemetry: ack, dirty_summary, dirty_bank, changes_since, vs_status, dirty_clear_all

Pattern that works well (hybrid)
State changes: always go through VS so everyone converges on the same truth.
    Master writes vs_set(...) â†’ IÂ²C handler on Core0 updates VS and may trigger a reaction (optional).
    UI changes a widget â†’ writes VS; master learns via changes_since or a cheap ackâ†’dirty_summaryâ†’dirty_bank pass.

Immediate reactions: donâ€™t poll VS on Core0 for master-originated changes.
    In the i2c_vs_set object, after updating VS, you can:
    set a tiny subsystem kick flag (atomic bool) that the main loop checks next tick, or
    push the slot index into the â€œchanges-sinceâ€ ring you already have and let a central â€œwatcherâ€ dispatch quickly, or
    for truly trivial actions (e.g., K_ACTIVE_SCREEN), call the apply helper (guarded) right there.

Low-latency notice for Core1: the master is bus-initiator, so it canâ€™t be â€œinterruptedâ€ by the slave.
Thatâ€™s why we built A1â€“A6:
    ACK bit tells you â€œanything changedâ€.
    Dirty summary + dirty bank fetch exactly what changed, quickly.
    Changes-since ring is the efficient path for sparse updates (no sweeping).
    Poll at 10â€“50 ms; payloads are tiny, CPU cost negligible.

Transaction groups (optional but handy):
    Master writes multiple keys (e.g., 10 volume bands) and then sends a commit command or bumps a K_TXN_SEQ VS key last.
    Core0 only applies the group when it sees the commit/seq change (prevents flicker and half-applied states).

Ownership/lease (optional):
    If you ever need to temporarily prefer master input over UI, add a K_OWNER with an expiry 
    timestamp; UI checks before committing and either defers or negotiates.

Concrete mapping (cheat-sheet)
Active Screen / Focus â†’ VS (System(...) keys). Keep i2c_scrCng as a thin shim that just writes those keys.

LEDs
    LedMask â†’ VS (durable).
    â€œBlink pattern 500 msâ€ â†’ command (i2c_led_blink {mask,duration,patternId}).

Audio
    Volume â†’ VS.
    â€œPlay clickâ€ / â€œStart tone 1 kHz, 100 msâ€ â†’ command.

Keyboard
    Snapshot (pressedMask) â†’ VS.
    Edges â†’ your existing i2c_getKb (or also append to change ring if master wants edges).

Config / Modes â†’ VS (+ optional â€œcommitâ€ command if batches matter).

Persistence â†’ command (â€œsave to flashâ€); the values come from VS.

Addressing the â€œmust poll VSâ€ concern
Slave/Core0: No. For master-writes, the slave is already in the IÂ²C receive handler; 
    it can react instantly after updating VS. Polling is only for changes originating from elsewhere (UI/sensors), 
    where your dirty tracking makes polling extremely cheap and targeted.
    Master/Core1: Because itâ€™s the bus master, it does pollâ€”but youâ€™ve already optimized that path (ACKâ†’Summary/Bank or changes_since). 
    Itâ€™s a few bytes every 10â€“50 ms; practically free.

Optional niceties (if you want even snappier behavior)
    Add a FLAG_NOTIFY bit in your vs_set header. If set, the slave can prioritize that key in its watcher pipeline (or run the reaction immediately). 
    Same effect as above, just explicit.
    A batch vs_set command to write N slots in one IÂ²C transaction, then a single â€œcommitâ€ command. 
    Useful when you want atomic appearance from the UIâ€™s perspective.

Bottom line:
    Put truth into the ValueStore (so everything is observable, persistent, and consistent).
    Use commands for events, commits, and telemetry.
    On the slave, react to master-writes immediately in the IÂ²C handler (or a one-tick kick), so thereâ€™s no â€œpolling delayâ€ worry.
    On the master, rely on the ACK/dirty/ring flow for efficient discovery of UI-originated changes.

-------250806_1 _---
default widget values from VS
VS value updating via widgets

--- Things to do --
 in core 1 need to use a shared file so both cores use the same indexes, like the screen names (ScreenEnum::TESTSCREEN)

 // shared ids.hpp
inline constexpr uint16_t to_screen_id_6(ScreenEnum e) {
    return static_cast<uint16_t>(static_cast<uint16_t>(e) & 0x3F); // or your exact macro
}
// Core-1:
static constexpr uint16_t SID_TEST = to_screen_id_6(ScreenEnum::TESTSCREEN);

-- 250911 --
all working correctly, need to remove versions and ring buffer and add lastCHangeWriter
 -- 250914 --
 Everything working correctly,
 no version or ring buffer in value store
 menu screen navigating correctly
 animations working
 all core 0 and core 1 demo working